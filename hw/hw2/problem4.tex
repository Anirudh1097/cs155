\begin{prob}  (CSRF Defenses) 
\end{prob}

\noindent \textit{a) In class we discussed Cross Site Request Forgery (CSRF) attacks against web sites that rely solely on cookies for session management. Briefly explain a CSRF attack on such a site}\\

Let $V$ be a victim browser, $S$ be a victim site, and $M$ be a malicious site. Suppose $S$ relies solely on cookies for session management. A typical CSRF attack would go like this: First, $V$ visits $S$ routinely, authenticates himself and establishes a cookie-based session with the site $S$. While the session is still active, $V$ visits is lured into visiting the malicious site $M$ (maybe in another tab, or window, lured in from a spam email). The designer of the malicious site presumably knows very well how the victim site $S$ works (he may have an account there and inspected the source to see what forms are used for the site to POST sensitive data, make changes). When $M$ serves the innocent looking content it also includes a hidden iframe with a form similar to the ones in the site $S$ which POSTs to a url in $S$. This form presumably is state changing, has a desired malicious affect (think transfer money, etc.), has all right parameter names and action URL, and can be filled out without user input. The iframe then contains javascript to submit the form immediately. When $V$'s browser submits the form to $S$, it will include $V$'s cookies for the site $S$ in the HTTP headers of the request. Finally, when $S$ gets the request it does not know in which context the request originated from and only sees $V$'s cookie, and the POST parameters. Since $S$ uses the cookie solely to authenticate $V$'s session then it will think that the request came legitimately from $V$ and will perform the request for the attacker.  \\

\noindent \textit{b) A common CSRF defense places a token in the DOM of every page (e.g. as a hidden form element) in addition to the cookie. An HTTP request is accepted by the server only if it contains both a valid HTTP cookie header and a valid token in the POST parameters. Why does this prevent the attack from part (a)?}\\

First, by checking the HTTP cookie header the server can identify which browser a request came from. Second, by generating a secret token that the server includes as a hidden input field for every form that it serves, we can be confident that forms that come back with a valid secret token were served by the server to the user and were not crafted by an attacker. Implicit in all of this is the assumption that secret validations tokens will be hard to guess, and hence the unguessability will provide unforgettability for forms. If an attacker wanted to perform the attack from part (a) he would be stuck when creating the form in the hidden iframe that POSTs to the victim site since he would not know what token to fill in for the secret validation field. \\

\noindent \textit{c) One approach to choosing a CSRF token is to choose one at random. Suppose a web site chooses the token as a fresh random string for every HTTP response. The server checks that this random string is present in the next HTTP request for that session. Does this prevent CSRF attacks? If so, explain why. If not, describe an attack.}\\

\textbf{This prevents CSRF attacks. } By generating a fresh random string for every HTTP response the web site makes it practically impossible to guess what secret token a given user has been assigned at some point in time (we would also probably like secret tokens to expire at some point so that old valid secret tokens cannot be used in the future and hence do not accumulate). As we mentioned in part (b) the unguessability of the secret token provides unforgettability to the forms sent by the server and prevents against CSRF attacks. In this case a fresh random token per HTTP request provides the secret validation tokens with unguessability.\\

\noindent \textit{d) Another approach is to choose the token as a fixed random string chosen by the server. That is, the same random string is used as the CSRF token in all HTTP responses from the server over a given time period. You may assume that the time period is chosen carefully. Does this prevent CSRF attacks? If so, explain why. If not, describe an attack.}\\


\textbf{This does not prevent CSRF attacks. } To illustrate an attack suppose a victim website $S$ chooses a fixed CSRF token $X$ that it includes in all of its HTTP responses from time $t=0$ to time $t=T$. The attacker $A$ knows this is how the server chooses its secret validation tokens. Assume that the victim browser $B$ has already logged in to the site $S$ during that time period. The attacker $A$ has an account on the site $S$ as well and will also log in the time period between $t=0$ and $t=T$. After logging in the attacker goes to some page on the site that contains a form\footnote{or any other form really} that he is interested in using during the exploit (think a transfer money form) The attacker then looks at the source for this page, finds the hidden secret validation token $X$ for this form and remembers it. Next, the attacker $A$ puts a hidden iframe into his malicious website with a form for the site $S$ (transfer money form) that is preopulated to do something malicious, includes the secret validation token with value $X$, and has some javascript to automatically submit the form. The attacker $A$ then lures $B$ to the malicious website $M$ during the time period $0<t<T$ and when $B$ visits $M$ the hidden iframe will submit the malicious form with the correct secret validation token for that time period and the browser's cookie for $S$. The request will go through and the attacker will succeed.\\

\noindent \textit{e) Why is the Same-Origin Policy important for the cookie-plus-token defense?}\\

Throughout this discussion we have mentioned that the malicious website $M$ would have to guess the secret validation token for pages in the victim site $S$ if he wanted to mount a CSRF attack. Implicit in this is the assumption that the malicious site $M$ cannot simply reach out and access content (the secret validation token in this case) from site $S$'s in the victim browser $B$. This is guaranteed by the SOP. Without the SOP CSRF attacks would be very simple. If a victim browser $B$ was logged into a victim site $S$ then the malicious page $M$ could simply contain a hidden iframe that loads a page from the site/origin $S$ which contains the form he is interested in. The attacker could then simply use javascript to reach into that iframe's content and extract the secret validation token, put it into his own malicious form and effectively create a legitimate form. Then he would proceed as before and successfully mount a CSRF attack. 

\textbf{So SOP is crucial to the cookie-plus-token defense since it ensures that a malicious website $M$ cannot simply load content from the victim site $S$ into the victim browser $B$ and read off the secret validation token to create a legitimate form. Without the ability to do this the attacker has to resort to guessing the token.} 
