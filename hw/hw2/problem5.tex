\begin{prob}  (Firewalls and Fragmentation)
\end{prob}

\noindent The IP protocol supports fragmentation, allowing a packet to be broken into smaller fragments as needed and re-assembled when it reaches the destination. When a packet is fragmented it is assigned a 16-bit packet ID and then each fragment is identified by its offset within the original packet. The fragments travel to the destination as separate packets. At the destination they are grouped by their packet ID and assembled into a complete packet using the packet offset of each fragment. Every fragment contains a one bit field called ``more fragments'' which is set to true if this is an intermediate fragment and set to false if this is the last fragment in the packet. We discussed the way small offsets can allow the data in one fragment to overlap information in the preceding fragment. However, overlapping fragments should not occur in normal network traffic.\\

\textit{In class we mentioned that when fragments with overlapping segments are re-assembled at the destination, the results can vary from OS to OS. Give an example where this can cause a problem for a network-based packet filtering engine that blocks packets containing certain keywords. How should a filtering engine handle overlapping fragments to ensure that its filtering policy is not violated?}\\

Suppose that the filtering engine wants to filter out the keyword ``communism" but not the words ``community" or ``small". If we want to send the word ``communism" to a destination IP address inside the network ``censored" by the filtering engine without the filtering engine blocking it we can do the following:\\
\indent \textbf{Step 1: }Send an IP with packet ID $X$, packet offset equal to 0, the more fragments bit set on, and where the payload\\\indent starts with the word ``community".\\
\indent \textbf{Step 2: }Immediately after send another IP packet to the same destination, with packet ID $X$, the more fragments bit\\\indent set on, with packet offset equal to $sizeof(IP\ header) + 7$, and where the payload starts with the word ``small".\\
\indent \textbf{Step 3: }Finally send another IP packet to the same destination with packet ID $X$, the more fragments bit set off, with\\\indent packet offset equal to $sizeof(IP\ header)+9$, and where the payload starts with space characters.\\

Since none of these packets contain blacklisted words in their payload then none will be discarded by the filtering engine. However when they are grouped and reassembled into a single IP packet, the chosen packet offsets will make them overlap and will cause them to reassemble into the word ``communism". Another approach would be to have the word ``communism" be at the boundary of two adjacent non-overlapping fragments (i.e. the first fragment would have the characters ``commun" as the last characters of its payload and the next fragment would have ``ism" as the first characters of its payload).\\

I have several ideas on how the filtering engine should handle overlapping fragments in order to ensure the filtering policy is not violated. \\

\textbf{Idea 1: } In IPv6 packets are never fragmented by routers (when the package size exceeds some MTU the packet is dropped and an ICMPv6 Packet too Big is sent to the source host). Considering this we could have a policy on IPv6 packets that would just drop any fragmented packets at the filtering engine (packets with the more fragments bit set on). Normal traffic should not contain fragmented packets and hence when we encounter any we can be suspicious. By disallowing any fragmentation we can make sure that the filtering policy will not be violated since the two approaches described above are based on fragmentation.\\

\textbf{Idea 2: } The filtering engine will maintain state per connection in order to determine whether a fragment (an IP packet with the more fragments bit set on) overlaps with other fragments for the same packet ID. The filtering engine will forward along fragments as normal. Only when it comes across a fragment that overlaps with other fragments, the filtering engine will discard that packet and drop in on the floor. Since overlapping fragments should not occur in normal network traffic we can safely assume that it is fine to interrupt connections where that happens. Furthermore, this approach makes sure that the filtering policy is not violated since no overlapping fragments are let through. In order to do this the filtering engine will need to remember the packet offset and the packet length for all fragments for a given packet ID for a given open connection. With this information it can determine whether a given fragment coming in overlaps with previously received fragments for that packet ID. The filtering engine can garbage collect all this state when it has received the last fragment for a packet ID in a given connection.\\

\textbf{Idea 3: } Whenever the filtering engine at the network gateway comes across a packet with the more fragments bit set on it will buffer it and wait for all other fragments with the same packet ID to arrive. When the last one arrives with the more fragments bit set off then the filtering engine will perform the reassembly of the fragments and will decide whether to filter out the reassembled packet or not depending on whether its payload contains blacklisted keywords. This approach requires the filtering engine to potentially buffer several fragments per open connection every time there is fragmentation. However, since IP packets are at most 65,535 bytes in length at least the buffering space needed per connection would be bounded since in total all fragments cannot be more than 65,535 bytes.