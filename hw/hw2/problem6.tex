\begin{prob}  (DNSSEC) 
\end{prob}

\noindent DNSSEC (DNS Security Extensions) is designed to prevent network attacks such as DNS record spoofing and cache poisoning. Generally, the DNSSEC server for example.com will posses the IP address of www.example.com. When queried about this record that it possesses, the DNSSEC server will return its answer with an associated signature. If the DNSEC server is queried about a host that does not exist, such as doesnotexist.example.com, the server uses NSEC or NSEC3 to show that the DNS server does not have an answer to the query.\\
\indent Suppose a user R (a resolver, in DNS terminology) queries a DNSSEC server S, but all of the network traffic between R and S is visible to a network attacker N. The attacker N may read requests from R to S and may send packets to R that appear to originate from S.\\

\noindent \textit{a) Why is authenticated denial of existence necessary? To answer this question, assume that S sends the same unsigned DOES-NOT-EXIST response to any query for which it has no matching record. Describe a possible attack.}\\

In this attack we assume $N$ knows the format of the unsigned DOES-NOT-EXIST response that $S$ sends for no matching records ($N$ can simply query $S$ for a record that does not exist--just keep trying random hostnames until it gets one--and learn this). A simple attack would be that for every DNS request that $R$ sends to $S$ (which $N$ will read) we will have $N$ respond with the unsigned DOES-NOT-EXIST response, make it look like it originated from $S$, and race $S$'s response, whatever it may be. In this way, if $N$'s response arrives at $R$ first then $N$ will have poisoned the DNS cache entry for that record if the record did in fact exist. If this is done over a long time period one can imagine that $N$ would be able to poison most of $R$'s DNS cache. All of the users that use $R$ as a DNS resolver would then get DOES-NOT-EXIST responses for all DNS queries, resulting in a DoS attack. \\

\noindent \textit{b) Assume now that S cryptographically signs its DOES-NOT-EXIST response, but the response does not say what query it is a response to. How is an attack still possible?}\\

\textbf{An attack is still possible}. For this attack we can also assume $N$ knows the signed generic DOES-NOT-EXIST response that $S$ sends for no matching records ($N$ can simply query $S$ for a record that does not exist--just keep trying random hostnames until it gets one--and learn this). Now that $N$ knows this, every time he reads a DNS query from $R$ to $S$ he will respond with the signed generic DOES-NOT-EXIST response and make it look like it originated from $S$. Again, if this response wins the race against the legitimate response from $S$ then $N$ will poison $R$'s DNS cache in case that record did exist. In the same way as before this can turn into a DoS attack against the users of $R$.\\

\noindent \textit{c) A DNSSEC server may send a signed NSEC response to a query that does not have a matching record (such as doesnotexist.example.com). An NSEC response contains two names, corresponding to the existent record on the server that immediately precedes the query (in lexicographic order), and the existent record that immediately follows the query. For example, if a DNSSEC server has records for a.example.com, b.example.com, and c.example.com, the NSEC response to a query for (non-existent) abc.example.com contains a.example.com and b.example.com because these come just before and just after the requested name. To be complete, NSEC records also wrap-around, so a query for a non-existent name after the last existent name will receive an NSEC containing the last and first existent names.\\\\
How should the resolver use the information contained in NSEC records to prevent the attacks you described in previous parts of this problem?}\\

The first attack is easily defeated since the DOES-NOT-EXIST response there was not signed. Hence, if there is no signature or if the signature does not match the response the resolver $R$ will simply discard the DOES-NOT-EXIST response. For the second attack, if $R$ queries $S$ for a hostname that does exists and gets a signed DOES-NOT-EXIST response but that does not specify what query it is a response to (does not specify next and previous valid hostnames) then the resolver will not cache the association. Alternatively if the attacker decides to include spoofed next and pref hostnames along with the DOES NOT EXIST response then since he does not have $S$'s private key he will not be able to generate a valid signature for the message and hence the message will be discarded by $R$ when it verifies the signature. \\

\noindent \textit{d) NSEC leaks information that may be useful to attackers on the Internet. Describe how an attacker can use NSEC to enumerate all of the hosts sharing a common domain-name suffix. How is this information useful for attackers?}\\

An attacker can ``map out" all the holes (and thus enumerate all the valid hostnames) sharing a common domain-name suffix $X$ as follows: \\

\noindent 0) Initialize $hostname=a.X$\\
1) The attacker send a DNS query for $hostname$\\
2) If he gets back a response that is not a DOES-NOT-EXIST response he knows that $hostname$ is a valid hostname, remembers it, and proceeds to 1) with $hostname$ equal to the next hostname in lexicographical order\\
3) If he gets back a DOES-NOT-EXIST response along the $prev$ and $next$ valid hostnames then he immediately knows than no hostnames lexicographically between $prev$ and $next$ are valid hostnames, and he remembers this. Additionally he knows $prev$ and $next$ are valid hostnames so he remembers them. He then proceeds back to 1) with the hostname that lexicographically follows $next$.  \\
-- The algorithm terminates when the attacker tries to iterate with a $hostname$ it has seen before (a valid hostname it already knows about). At this point the attacker has mapped all valid hostnames in the $.X$ domain.\\

Attackers may be interested in enumerating all hosts sharing a common domain-name suffix for various reasons. If the domian-name belongs to an organization they want to do a DDoS attack on with a botnet and they want to make sure they DDoS all hosts within that network are attacked then this information is invaluable. Clearly the attacker could not try to attack every single possible hostname since there are exponentially many of these so it would be wasteful of resources and the cost would be prohibitive (most random hostnames in this space will probably not exist). By knowing all the valid hostnames the attacker can target specifically the valid hostnames and do a more effective DDoS attack. Another reason is that by enumerating all hosts an attacker could review the hostnames looking for particularly revealing/interesting names to attack, like mail servers or sensitive database servers. Organizations don't like to make public the hostnames of machines containing sensitive data and attackers would love to know these. \\

\noindent \textit{e) NSEC3 is designed to prevent DNS responses from revealing unnecessary information. NSEC3 uses the lexicographic order of hashed records, instead of their unhashed order. In response to a query without a matching record, NSEC3 will return the hashed names that are just before and just after the hash of the query. For example, on a server containing a.example.com, b.example.com, and c.example.com, if a hashes to 30, b to 10, c to 20, and abc to 15, the NSEC3 response to a query for abc.example.com would contain 10.example.com and 20.example.com. Hashed names are also assumed to wrap around, in the same way as unhashed names in NSEC.\\\\
Explain how a resolver should verify the validity of a response under NSEC3?}\\

First it will check the signature of the response to make sure the response came from the legitimate DNS server and has not been tampered with.\footnote{decrypt the signature with the public key of the DNS server and check it matches the response}. If this check passes and the response is not a DOES-NOT-EXIST response then the resolver will cache the hostname-IP association. If the response was a DOES-NOT-EXIST response then the resolver will hash the name of the hostname it originally asked for (in the example above it it asked for $abc.example.com$ so it will hash $abc$ to get 15) and make sure that this hash lies in between (lexicographically) the next and previous valid hashes that the DOES-NOT-EXIST record includes. If it does not fall inside this interval/gap then the DNS response will be discarded. If it does fall into the gap then it will cache the association hostname: DOES-NOT-EXIST.
